apiVersion: v1
kind: ConfigMap
metadata:
  name: cluster-status-script
  namespace: monitoring
data:
  status_check.py: |
    import os
    import json
    import urllib.request
    import urllib.parse
    from datetime import datetime

    WEBHOOK_URL = os.environ.get("DISCORD_WEBHOOK_URL")
    PROMETHEUS_URL = "http://monitoring-kube-prometheus-prometheus.monitoring.svc:9090"

    def query_prometheus(query):
        params = urllib.parse.urlencode({'query': query})
        url = f"{PROMETHEUS_URL}/api/v1/query?{params}"
        try:
            with urllib.request.urlopen(url) as response:
                data = json.loads(response.read().decode())
                if data['status'] == 'success' and data['data']['result']:
                    return data['data']['result'][0]['value'][1]
        except Exception as e:
            print(f"Error querying {query}: {e}")
        return "N/A"

    def format_bytes(size):
        try:
            size = float(size)
            power = 2**10
            n = 0
            power_labels = {0 : 'B', 1: 'KiB', 2: 'MiB', 3: 'GiB', 4: 'TiB'}
            while size > power:
                size /= power
                n += 1
            return f"{size:.2f} {power_labels.get(n, '?')}"
        except:
            return size

    def main():
        if not WEBHOOK_URL:
            print("No webhook URL provided")
            return

        # Queries
        # CPU: Avg usage AND Max usage
        # Avg:
        cpu_avg = query_prometheus('100 - (avg(rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)')
        # Max node:
        cpu_max = query_prometheus('max(100 - (rate(node_cpu_seconds_total{mode="idle"}[5m]) * 100))')
        
        # Memory
        mem_usage = query_prometheus('sum(node_memory_MemTotal_bytes) - sum(node_memory_MemAvailable_bytes)')
        mem_total = query_prometheus('sum(node_memory_MemTotal_bytes)')
        
        # Status - count(kube_node_info) is often cleaner for node count
        nodes_up = query_prometheus('count(kube_node_info)')
        pods_running = query_prometheus('count(kube_pod_status_phase{phase="Running"})')
        
        # Storage (Longhorn)
        pvc_usage = query_prometheus('sum(longhorn_node_storage_usage_bytes)')
        pvc_total = query_prometheus('sum(longhorn_node_storage_capacity_bytes)')

        # Formatting
        try:
            cpu_text = f"Avg: {float(cpu_avg):.1f}% | Max: {float(cpu_max):.1f}%"
        except: cpu_text = "N/A"

        try:
            mem_percent = (float(mem_usage) / float(mem_total)) * 100
            mem_text = f"{format_bytes(mem_usage)} / {format_bytes(mem_total)} ({mem_percent:.1f}%)"
        except: mem_text = "N/A"

        try:
            storage_percent = (float(pvc_usage) / float(pvc_total)) * 100
            storage_text = f"{format_bytes(pvc_usage)} / {format_bytes(pvc_total)} ({storage_percent:.1f}%)"
        except: 
            # Fallback if longhorn metrics specific query failed, try generic
            storage_text = f"Used: {format_bytes(pvc_usage)}"

        embed = {
            "title": f"ℹ️ Cluster Status Check - {datetime.now().strftime('%H:%M UTC')}",
            "color": 3066993, # Green/Blue
            "fields": [
                {"name": "Nodes", "value": str(nodes_up), "inline": True},
                {"name": "Pods", "value": str(pods_running), "inline": True},
                {"name": "CPU Load", "value": cpu_text, "inline": True},
                {"name": "Memory", "value": mem_text, "inline": True},
                {"name": "Storage (Longhorn)", "value": storage_text, "inline": True}
            ],
            "footer": {"text": "10-minute Heartbeat"}
        }

        payload = {"embeds": [embed]}
        
        url = WEBHOOK_URL
        # Handle file-based secret if needed (though we inject env var directly mostly)
        if os.path.isfile(url):
            with open(url, 'r') as f:
                url = f.read().strip()

        req = urllib.request.Request(url, data=json.dumps(payload).encode(), headers={'Content-Type': 'application/json', 'User-Agent': 'StatusReporter'})
        try:
            urllib.request.urlopen(req)
            print("Status sent successfully")
        except Exception as e:
            print(f"Error sending to Discord: {e}")

    if __name__ == "__main__":
        main()
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: cluster-status-reporter
  namespace: monitoring
spec:
  schedule: "*/10 * * * *"
  successfulJobsHistoryLimit: 1
  failedJobsHistoryLimit: 1
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: reporter
            image: python:3.9-slim
            command: ["python", "/app/status_check.py"]
            env:
            - name: DISCORD_WEBHOOK_URL
              valueFrom:
                secretKeyRef:
                  name: monitoring-discord-webhooks
                  key: info-alerts
            volumeMounts:
            - name: script
              mountPath: /app/status_check.py
              subPath: status_check.py
          restartPolicy: OnFailure
          volumes:
          - name: script
            configMap:
              name: cluster-status-script
